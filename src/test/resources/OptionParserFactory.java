import java.util.Arrays;

import org.mulinlab.varnote.constants.GlobalParameter;
import org.mulinlab.varnote.utils.enumset.IndexType;
import joptsimple.OptionParser;

public class OptionParserFactory {
	public static OptionParser getParserForQuery() {
		OptionParser parser = new OptionParser();
		parser = getParserDefault(parser);
		parser.acceptsAll(Arrays.asList("q", "q-region"), "Region specified as the format \"chr:beginPos-endPos\"")
			.withRequiredArg().describedAs("1:<str>").ofType(String.class);  //查询文件
		
		parser = getParserForDatabase(parser);
		parser.acceptsAll(Arrays.asList("j", "use-jdk-inflater"), "Use the JDK Inflater instead of the IntelInflater for reading index.")
			.withOptionalArg().describedAs("32:[bool]");
		
		parser.acceptsAll(Arrays.asList("l", "label"), "Include this option to print database names as the first column of the result.")
			.withOptionalArg().describedAs("31:[bool]");
		return parser;
	}
	
	public static OptionParser getParserForOverlap() {
		OptionParser parser = new OptionParser();

		parser.accepts("config", "Run program (overlap or anno) using configuration file (once activating, other command line parameters are invalid).")
			.withOptionalArg().describedAs("90:[file]").ofType(String.class); 
		parser.acceptsAll(Arrays.asList("q", "q-file"), "Path of file input file (support plain text or compressed files, including gzip and block gzip)."
				+ " Currently, vcf, bed or tab format file are supported. File format could be identified from file suffix (e.g vcf, bed, vcf.gz, bed.gz), or else you should define the exact file format with -f option")
			.withRequiredArg().describedAs("1:<file>").ofType(String.class);  //查询文件
		
		parser = getParserDefault(parser);
		parser = getParserForDatabase(parser);
		parser = getParserForFormat(parser);
		parser = getParserForOutput(parser);
				
//		parser.accepts("mode", ErrorMsg.VANNO_RUN_MODE)
//		.withOptionalArg().describedAs("Mode").ofType(Integer.class).defaultsTo(1);  //模式，0号是循环单次tabix查询 1号是两种方式结合查询		
//		
		parser.acceptsAll(Arrays.asList("t", "thread"), "Number of used threads (defualt 1). Sets thread to -1 to get thread number by available processors automatically. ")
		.withOptionalArg().describedAs("41:[int]").ofType(Integer.class).defaultsTo(1); //程序所需线程数
		
		parser.acceptsAll(Arrays.asList("n", "count"), "Counting Mode. Fast counting of intersection records for each database without investigate detailed annotations.")
		.withOptionalArg().describedAs("42:[bool]");
		
		parser.acceptsAll(Arrays.asList("j", "use-jdk-inflater"), "Use the JDK Inflater instead of the IntelInflater for reading index.")
		.withOptionalArg().describedAs("43:[bool]");
		
		parser.accepts("verbose", "Set to print log.")
		.withOptionalArg().describedAs("44:[bool]"); 

		parser.accepts("unzip", "IntersetOutput compression. By default, the program will compress the output file using block gzip. ")
		.withOptionalArg().describedAs("45:[bool]").defaultsTo("false"); 
		return parser;
	}
	
	public static OptionParser getParserForAnno() {
		OptionParser parser = getParserForOverlap();
		parser.acceptsAll(Arrays.asList("Q", "overlap-file"), "Path of overlap file (an output file includes comment lines generated by the VarNote overlap program).")
			.withOptionalArg().describedAs("3:[file]").ofType(String.class);
		
		parser.acceptsAll(Arrays.asList("a", "anno-config"), "Path of annotate configuration file. The program annotates query record with all information in databases if without this option. "
				+ "If -a is not defined, the program will search file named /path/to/query/query_file + \".annoc\" under the folder of the query file.")
		.withOptionalArg().describedAs("4:[file]").ofType(String.class); 
		
		parser.acceptsAll(Arrays.asList("r", "force-overlap"), "	Force overlap mode. Force the program to omit REF and ALT matching and allele specific feature extraction.")
		.withOptionalArg().describedAs("50:[bool]").ofType(String.class); 

		//		parser.accepts("query-columns", "QueryRegion Column Name").withOptionalArg().describedAs("QueryRegion Column Name").withValuesSeparatedBy(',').ofType(String.class);
		parser.acceptsAll(Arrays.asList("V", "vcf-header-for-bed"), "VCF output header file. This file is required when the format of query file is BED or TAB-delimited, but the format of annotation output is VCF. ")
		.withOptionalArg().describedAs("51:[file]").ofType(String.class); 
		
		parser.acceptsAll(Arrays.asList("F", "anno-format"), "Annotation output file format. ")
		.withOptionalArg().describedAs("52:[str (vcf,bed)]").ofType(String.class);
		
		parser.accepts("anno-out", "IntersetOutput path to result file.")
		.withOptionalArg().describedAs("53:[str]").ofType(String.class); 
		return parser;
	}
	
	public static OptionParser getParserForIndex() {
		OptionParser parser = new OptionParser();
		parser = getParserDefault(parser);
		
		parser.acceptsAll(Arrays.asList("i", "input"), "Path of file (bgz format) to be indexed. The file must be position-sorted (first by sequence name and then by leftmost coordinate). ")
			.withRequiredArg().describedAs("1:<file>").ofType(String.class);  //待索引的文件	
		
		parser = getParserForFormat(parser);
		
		parser.acceptsAll(Arrays.asList("o", "out"), "IntersetOutput directory. By default the output files will be written into the same folder as the input file. ")
			.withOptionalArg().describedAs("31:[str]").ofType(String.class);		
		
		parser.acceptsAll(Arrays.asList("j", "use-jdk-deflater"), "Use the JDK Deflater instead of the IntelDeflater for writing index.")
			.withOptionalArg().describedAs("32:[bool]");
		
		parser.acceptsAll(Arrays.asList("h", "print-header"), "Print column header line.").withOptionalArg().describedAs("41:[bool]");
		parser.acceptsAll(Arrays.asList("m", "print-meta-data"), "Print meta lines, such as all VCF headers.").withOptionalArg().describedAs("42:[bool]");
		parser.acceptsAll(Arrays.asList("l", "list-chroms"), "List the sequence names stored in the index file.")
			.withOptionalArg().describedAs("43:[bool]");
		parser.acceptsAll(Arrays.asList("r", "replace-header"), "Replace the column header with a comma-separated string containing the header columns. Columns name should be separated by comma and the header string should be included with double quotation. ")
			.withOptionalArg().describedAs("44:[str]");
        return parser;
	}
	
	public static OptionParser getParserDefault(OptionParser parser) {
		//parser.accepts("help", ErrorMsg.PRINT_HELP);
		return parser;
	}
	
	public static OptionParser getParserForFormat(OptionParser parser) {
		parser.acceptsAll(Arrays.asList("f", "format"), "File format, valid values should be vcf, bed and tab. The tab format should be applied together with -c, -b, -e and -0. ")
			.withOptionalArg().describedAs("21:[str (vcf,bed,tab)]").ofType(String.class); 

		parser.acceptsAll(Arrays.asList("c", "chrom"), "Used with tab format(required), column of sequence name. ")
			.withOptionalArg().describedAs("22:[int (>=1)]").ofType(Integer.class); 
		
		parser.acceptsAll(Arrays.asList("b", "begin"), "Used with tab format(required), column of start chromosomal position. ")
			.withOptionalArg().describedAs("23:[int (>=1)]").ofType(Integer.class); 
		
		parser.acceptsAll(Arrays.asList("e", "end"), "Used with tab format(required), column of end chromosomal position. If missing, will set it same as the start position. ")
			.withOptionalArg().describedAs("24:[int (>=1)]").ofType(Integer.class); 
		
		parser.accepts("ref", "Used with bed or tab format, column of reference allele. Better to normalize allele before use the option.")
			.withOptionalArg().describedAs("25:[int (>=1)]").ofType(Integer.class).defaultsTo(-1); 
		
		parser.accepts("alt", "	Used with bed or tab format, column of alternative alleles. Better to normalize allele before use the option.")
			.withOptionalArg().describedAs("26:[int (>=1)]").ofType(Integer.class).defaultsTo(-1); 
		
		parser.acceptsAll(Arrays.asList("0", "zero-based"), "Used with tab format (optional), specify that the position in the data file is 0-based (e.g. UCSC files) rather than 1-based. ")
			.withOptionalArg().describedAs("27:[bool]");

		parser.accepts("header", "Indicate whether input file contains a column header line. If --header is included, the first line below the comment line will be considered as a header line. " + 
				"Header line could start with '#' or have no indicator. " + 
				"To facilitate the automatic inference, header should at least include CHROM and POS (or, alternatively, BEGIN and END) columns, while, REF, ALT and other columns are optional. Other column names could be any words defined by user. ")
			.withOptionalArg().describedAs("28:[bool]").ofType(String.class).defaultsTo("false"); 
		
		parser.acceptsAll(Arrays.asList("P", "header-path"), "Path of external file to include the header lines.")
			.withOptionalArg().describedAs("29:[file]").ofType(String.class); 
		
		parser.acceptsAll(Arrays.asList("C", "comment-indicator"), "Used with bed or tab format, skip lines started with comment indicator. Quote in comment indicator will be removed. Example: -C @@ (change comment indicator from ## to @@)")
			.withOptionalArg().describedAs("30:[str]").ofType(String.class).defaultsTo("##");	
		
		parser.acceptsAll(Arrays.asList("s", "skip"), "Skip first INT lines(including comment lines) in the data file(default 0).")
			.withOptionalArg().describedAs("21: [int]").ofType(Integer.class).defaultsTo(0);
		return parser;
	}
	
	public static OptionParser getParserForDatabase(OptionParser parser) {
		parser.acceptsAll(Arrays.asList("d", "d-file"),  "Local path or http/ftp address of indexed database files with either VarNote index (" + IndexType.VARNOTE.getExt() + " and " + IndexType.VARNOTE.getExtIndex() + ") or Tabix index("+ IndexType.TBI.getExtIndex() + ") in the same location " +
				"(multiple files should be separated by comma with no space).")
			.withRequiredArg().describedAs("2:<file-list>").withValuesSeparatedBy(',').ofType(String.class);   //查询的数据库文件
		
		parser.accepts("d-index", "Type of index. By default, the program will use " + GlobalParameter.PRO_NAME + " index system, valid values are "+ IndexType.TBI.getName() +" or " +
				IndexType.VARNOTE.getName() + " (multiple index should be separated by comma with no space). ")
			.withOptionalArg().describedAs("10:[str-list (" + IndexType.TBI.getName() + "," + IndexType.VARNOTE.getName() + ")]").withValuesSeparatedBy(',').ofType(String.class);   //查询的数据库文件
		
		parser.accepts("d-label", "Customize database name. By default, the program will use original database file names as labels of retrieved records in the output. In case duplicate names of different database files, the program accepts user-defined labels. ")
			.withOptionalArg().describedAs("11:[str-list]").withValuesSeparatedBy(',').ofType(String.class);   
		
		parser.accepts("d-type", "Mode of Intersection. 0: overlap mode, perform common interaction operation according to query and database formats; 1: exact match mode, force the program only to consider the chromosome position of database records that exactly match the corresponding chromosome position of query; 2: full close mode, force the program to report database records that overlap both endpoints of query interval regardless of original query and database formats. ")
			.withOptionalArg().describedAs("12:[int-list (0,1,2)]").withValuesSeparatedBy(',').ofType(String.class);
		
		return parser;
	}
	
	public static OptionParser getParserForOutput(OptionParser parser) {
		parser.acceptsAll(Arrays.asList("o", "out-floder"), "IntersetOutput directory path. By default the program will create a fold in /path/to/query/query_name_out. ")
			.withOptionalArg().describedAs("31:[str]").ofType(String.class);  //输出文件
	
		parser.accepts("out-mode", "IntersetOutput recording mode (default 2). 0 for \"only output query records\"; 1 for \"only output matched database records\"; 2 for \"output both query records and matched database records\". ")
			.withOptionalArg().describedAs("32:[int (0,1,2)]").ofType(Integer.class).defaultsTo(2);  	

		parser.accepts("loj", "Left outer join mode. The 'left outer join' mode reports each of query record regardless of whether containing intersected records. ")
			.withOptionalArg().describedAs("33:[bool]").defaultsTo("false"); 
		
		parser.acceptsAll(Arrays.asList("R", "remove-comment"), "Remove comment lines which are start with @ from output file.")
			.withOptionalArg().describedAs("34:[bool]").defaultsTo("false");
		return parser;
	}
}
